â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     INSTRUCTION MEMORY INITIALIZATION - SETUP COMPLETE âœ“                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”§ CHANGES MADE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ… instruction_memory.v - UPDATED
   - Moved from `initial` block (non-synthesizable) 
   - To `always @(posedge CLK or posedge RESET)` (synthesizable)
   - Added dual-mode support: synthesis + simulation

2. âœ… instruction_mem.hex - CREATED
   - Hex file for optional simulation use
   - Located in: code/accelerator/cpu_core/instruction_memory/

3. âœ… script.sh - UPDATED
   - Added +define+SIMULATION flag for VCS
   - Auto-copies hex file to simulation directory
   - Fixed paths (power_v5 â†’ power_v6)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ HOW IT WORKS NOW
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DUAL-MODE INSTRUCTION MEMORY                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Mode 1: SYNTHESIS (RTL Synthesis + PrimePower)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Uses: always @(posedge CLK or posedge RESET)
â€¢ Synthesizable: YES âœ“
â€¢ Creates: Actual flip-flops (1024 bytes of registers)
â€¢ Instructions: Hardcoded in Verilog
â€¢ Tools: rtl_shell, pwr_shell
â€¢ Result: Power consumption will be CORRECT (not 0.000W)

Code flow:
  always @(posedge CLK or posedge RESET) begin
    if (RESET) begin
      memory_array[0] <= 8'h19;  // Instruction bytes
      memory_array[1] <= 8'h00;
      ...
    end
  end

Mode 2: SIMULATION (VCS)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Uses: $readmemh() inside `ifdef SIMULATION
â€¢ Only active when: +define+SIMULATION flag set
â€¢ File: instruction_mem.hex
â€¢ Tools: VCS, Verdi
â€¢ Result: Can load different programs easily

Code flow:
  `ifdef SIMULATION
    initial begin
      $readmemh("instruction_mem.hex", memory_array);
    end
  `endif

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ FILE LOCATIONS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Source Files:
  code/accelerator/cpu_core/instruction_memory/
    â”œâ”€â”€ instruction_memory.v         â† Updated module
    â””â”€â”€ instruction_mem.hex           â† Hex file (optional)

During Simulation:
  code/accelerator/mesh/
    â”œâ”€â”€ mesh_tb.v
    â”œâ”€â”€ simv                          â† VCS executable
    â””â”€â”€ instruction_mem.hex           â† Auto-copied here by script.sh

During Synthesis:
  code/power/power_v6/
    â”œâ”€â”€ cpu_LIB/                      â† RTL synthesis library
    â””â”€â”€ (hex file NOT needed - using hardcoded values)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ WHY THIS FIXES THE POWER ISSUE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

BEFORE (Initial Block - Non-Synthesizable):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  initial begin
    memory_array[0] <= 8'h19;
    ...
  end

  Problem:
  âœ— Synthesis tools IGNORE initial blocks
  âœ— No flip-flops created
  âœ— Memory array optimized away (pruned)
  âœ— Power = 0.000W (module doesn't exist)

AFTER (Always Block - Synthesizable):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  always @(posedge CLK or posedge RESET) begin
    if (RESET) begin
      memory_array[0] <= 8'h19;
      ...
    end
  end

  Solution:
  âœ“ Synthesis tools RECOGNIZE this
  âœ“ Creates 1024 flip-flops (8 bits each)
  âœ“ Memory array PRESENT in netlist
  âœ“ Power = REAL value (e.g., 0.005W - 0.010W)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š EXPECTED POWER RESULTS (After Fix)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Component               Before Fix    After Fix
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Instruction Memory      0.000 W       0.005-0.010 W
Data Memory             0.010 W       0.010 W (unchanged)
CPU                     0.015 W       0.015 W (unchanged)
Neuron Bank             0.001 W       0.001 W (unchanged)
Router                  0.0001 W      0.0001 W (unchanged)
Network Interface       0.0002 W      0.0002 W (unchanged)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL (2x2 mesh, 4N)    ~0.11 W       ~0.12 W

Note: Instruction memory should now contribute ~5-10% of total power

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ” HOW TO VERIFY THE FIX
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Check Synthesis Log:
   grep -i "instruction_memory" parametric_results_*/2x2_N4/rtl_synthesis.log
   
   Should see:
   âœ“ "Inferred memory devices in process"
   âœ“ "memory_array | Flip-flop | 1024 | Y | Y |..."

2. Check Power Report:
   cat parametric_results_*/2x2_N4/report_power.txt | grep IMEM
   
   Should see:
   âœ“ IMEM (instruction_memory_0)  0.00XX  0.00XX  0.00XX  0.01XX
   âœ— NOT: 0.000  0.000  0.000  0.000  N/A

3. Check Hierarchical Power:
   cat parametric_results_*/2x2_N4/power_by_module_2.txt | grep IMEM
   
   Should see non-zero values for each node's IMEM

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ INSTRUCTION MEMORY HEX FORMAT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

instruction_mem.hex format (for simulation):
  - One byte per line
  - Hexadecimal values
  - Little-endian byte order
  - No need for address labels
  - Comments allowed with //

Example:
  // Address 0x00-0x03: Instruction 1 (0x12345678)
  78  â† LSB (byte 0)
  56
  34
  12  â† MSB (byte 3)
  // Address 0x04-0x07: Instruction 2
  ...

To change program:
  1. Edit instruction_mem.hex
  2. Re-run VCS simulation
  3. (No need to change Verilog for simulation-only changes)

For synthesis:
  1. Edit the always @(posedge CLK) block in instruction_memory.v
  2. Re-run synthesis

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš™ï¸ VCS COMPILATION FLAGS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Old command:
  vcs -sverilog -full64 mesh_tb.v

New command (in script.sh):
  vcs -sverilog -full64 +define+SIMULATION mesh_tb.v

The +define+SIMULATION flag:
  â€¢ Enables the `ifdef SIMULATION block
  â€¢ Allows $readmemh() to work
  â€¢ Only affects VCS simulation, NOT synthesis

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸš€ WORKFLOW SUMMARY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

For Standard Use (Parametric Sweep):
  1. Run: ./run_parametric_sweep.sh
  2. Script automatically:
     - Copies instruction_mem.hex to simulation dir
     - Compiles VCS with +define+SIMULATION
     - Runs synthesis (uses hardcoded instructions)
     - Reports power (IMEM now has real values)

For Custom Programs (Simulation Only):
  1. Edit: instruction_mem.hex
  2. Run: ./run_single_config.sh 2 2 4
  3. View simulation results

For Custom Programs (Synthesis + Power):
  1. Edit: instruction_memory.v (always block)
  2. Recompile hex: (regenerate instruction_mem.hex if needed)
  3. Run: ./run_parametric_sweep.sh

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… BENEFITS OF THIS APPROACH
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ“ Synthesizable - Creates real flip-flops
âœ“ Accurate power - IMEM contributes to power analysis
âœ“ Flexible simulation - Can use hex files for different programs
âœ“ Dual-mode - Same Verilog works for both sim and synth
âœ“ Tool compatibility - Works with VCS, rtl_shell, pwr_shell
âœ“ No manual file copying - Script handles hex file placement
âœ“ Parameterized - Works with all mesh configurations

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ TECHNICAL NOTES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Q: Why use always @(posedge CLK) instead of initial?
A: Synthesis tools require clocked/sequential logic. Initial blocks
   are for simulation only and are ignored during synthesis.

Q: Why does synthesis ignore initial blocks?
A: Initial blocks describe simulation behavior, not hardware structure.
   Hardware (flip-flops) must have a clock and reset.

Q: Does this create actual ROM or RAM?
A: Creates flip-flops (registers). For large programs, use SRAM macros.

Q: What about area impact?
A: 1024 bytes = 8192 flip-flops. Expect ~0.01-0.02 mmÂ² in SKY130.

Q: Can I use different programs per node?
A: Yes, but you'd need to parameterize instruction_memory.v or
   use generate blocks to load different hex files per instance.

Q: What if I want true ROM (not flip-flops)?
A: Use SKY130 SRAM macros or ROM generators for production designs.
   Current approach is good for research/prototyping.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ NEXT STEPS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Test the fix:
   cd code/power/power_v6
   ./run_single_config.sh 2 2 4

2. Check synthesis log:
   grep "instruction_memory" parametric_results_*/2x2_N4/rtl_synthesis.log

3. Check power report:
   cat parametric_results_*/2x2_N4/report_power.txt | grep IMEM

4. If power is still 0.000:
   - Check synthesis warnings
   - Verify memory_array is inferred
   - Check if reset is properly connected

5. Run full sweep:
   ./run_parametric_sweep.sh

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

That's it! Your instruction memory is now properly synthesizable. ğŸ‰

â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
